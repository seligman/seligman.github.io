<!DOCTYPE html><html><head><meta charset="utf-8"/><link rel="icon" type="image/png" sizes="16x16" href="spyglass.png"/><title>Search</title><style>:root {color-scheme: dark;}html,body {background-color: #333;color: #ccc;font-family: "Roboto", sans-serif;font-size: 12pt;}a {color: #ccf;text-decoration: none;}.transcriptLink {font-size: 80%;font-weight: normal;}h1 {padding-left: 0.5em;margin-top: 1.5em;margin-bottom: 0.25em;border-bottom: 1px solid #777;font-size: 14pt;color: #888;}.item {padding-bottom: 0.25em;}ul {list-style-type: none;}li {margin-bottom: 0.5em;}a:hover {color: #ccf;text-decoration: underline;}.title {font-weight: bold;border-bottom-style: solid;border-bottom-width: 1px;border-bottom-color: #888;padding-left: 1em;padding-bottom: 0;margin: 0;font-size: 12pt;}.hit {text-indent: -2em;margin-left: 2em;}.created {font-size: 8pt;}input[type="text"] {background-color: #000;color: #cec;border-top-style: hidden;border-right-style: hidden;border-left-style: hidden;border-bottom-style: solid;border-bottom-width: 1px;border-bottom-color: #a8a8f2;padding: 2px;outline: none;font-size: 12pt;}</style><script>let contextBefore = 5;let contextAfter = 500;let info = null;let batches = null;let batchData = {};async function getData(data_num, start, len, loadMode='gzipDecode') {const resp = await fetch("./search_data_" + String(data_num).padStart(2, '0') + ".dat",{'headers': {'Range': 'bytes=' + start + "-" + (start + len - 1),},},);if (loadMode == 'gzipDecode') {const blob = await resp.blob();const ds = new DecompressionStream("gzip");const decomp = blob.stream().pipeThrough(ds);const decoded = await new Response(decomp).blob();const text = await decoded.text();const parsed = JSON.parse(text);return parsed;} else if (loadMode == 'json') {const text = await resp.text();const parsed = JSON.parse(text);return parsed;}}function showHit(item, search, showAll, batch, itemID, paginator) {let ret = [];let lastHit = 0;let findHits = handler => {let words = item[search['title'] ? 'title' : 'words'].toLowerCase();if (showAll) {handler(0, 0);} else if (search['regex']) {let target = search['terms'].join(' ');target = new RegExp(target, 'gi');while (true) {let hit = target.exec(words);if (hit == null) {break;}if (!handler(hit.index, hit[0].length)) {break;}}} else if (search['logic']) {if (search['logic_helper'](words)) {handler(0, 0);}} else {let target = search['terms'].join(' ').toLowerCase();let lastHit = -1;while (true) {let hit = words.indexOf(target, lastHit + 1);if (hit == -1) {break;}if (!handler(hit, target.length)) {break;}lastHit = hit;if (search['title']) {break;}}}};let lookup = null;let start = null;let speaker = null;let speakerPop = null;let counts = null;let showHit = (hitAt) => {if (paginator['skip'] > 0) {paginator['skip']--;} else {let hit = document.createElement((search['title'] || search['logic']) ? "div": "p");if (search['title'] || search['logic']) {hit.className = 'item';}ret.push(hit);let header;if (search['title'] || search['logic']) {link = document.createElement("a");hit.appendChild(link);header = hit;} else {header = document.createElement("h1");hit.appendChild(header);link = document.createElement("a");header.appendChild(link);header.className = "title";}link.href = item['link'];link.target = "_blank";link.innerText = (item['published'] == '1970-01-01' ? '' : (item['published'] + ": ")) + item['title'];if (batch !== null) {let span = document.createElement("span");header.appendChild(span);span.innerText = " ";let fullLink = document.createElement("a");header.appendChild(fullLink);fullLink.className = "transcriptLink";fullLink.innerText = "[transcript]";fullLink.target = "_blank";fullLink.href = "#" + batch[0] + "," + batch[1] + "," + batch[2] + "," + itemID;}if (!search['title'] && !search['logic']) {let lastSpeaker = '';let phraseStartAt = 0;let startAt = -1;let phrase = null;let endedSentence = false;for (let i = Math.max(0, hitAt - contextBefore); i <= (showAll ? (start.length - 1) : Math.min(hitAt + 1 + contextAfter, start.length - 1)); i++) {if (!showAll) {if (startAt >= 0 && ((start[i] / 100) - startAt) > 60) {break;}}let curSpeaker = "";if (phrase === null || endedSentence && (lastSpeaker != speaker[i] || (start[i] - phraseStartAt) >= 45) || (start[i] - phraseStartAt) >= 120) {if (lastSpeaker != speaker[i]) {curSpeaker = speakerPop[speaker[i]];}lastSpeaker = speaker[i];phraseStartAt = start[i];if (startAt === -1) {startAt = phraseStartAt;}let text = document.createElement('p');hit.appendChild(text);text.className = "hit";let time = document.createElement('span');text.appendChild(time);let at = start[i];let val = "";val += Math.floor(at / 3600).toString() + ":";val += (Math.floor(at / 60) % 60).toString().padStart(2, "0") + ":";val += (at % 60).toString().padStart(2, "0") + ":";time.innerText = val;phrase = document.createElement('span');text.appendChild(phrase);}let curWord = item['words'].slice(lookup['word'][i], lookup['word'][i+1]-1);phrase.innerText += curSpeaker + " " + curWord;curSpeaker = "";endedSentence = ".?!".includes(curWord.slice(-1));}}paginator['bail']--;paginator['found']++;}paginator['pos']++;if (showAll) {return false;}if (paginator['bail'] == 0) {let comment = document.createElement('span');ret.push(comment);comment.innerText = "[View Next Page]";comment.style.cursor = 'pointer';comment.onclick = () => {window.scrollTo(0, 0);searchFor(search['orig'], skip=paginator['pos']).then();};return false;}return true;};findHits((hit, size) => {if (lookup == null) {lookup = {'pos': [], 'word': []};let wordNum = -1;let off = 0;let wasSpace = true;for (let x of item['words']) {if (wasSpace) {wordNum++;lookup['word'].push(off);}wasSpace = (x == ' ');lookup['pos'].push(wordNum);off++;}lookup['word'].push(off+1);let last = 0;start = [];for (let cur of item['start']) {last += cur;start.push(last);}speakerPop = {};speaker = item['speaker'].split('');counts = {};speaker.map(x => {counts[x] = counts[x] ? counts[x] + 1 : 1;});counts["@"] = 0;counts = Object.entries(counts);counts.sort((a, b) => {if (b < a) {return -1;}if (a > b) {return 1;}return 0;});counts.map(x => {if (x[0] == "@") {speakerPop[x[0]] = '';} else {speakerPop[x[0]] = ' ' + String.fromCharCode("A".charCodeAt(0) + Object.keys(speakerPop).length) + ": ";}});}if (!showHit(lookup['pos'][hit])) {return false;}return true;});return ret;}async function showTranscript(data_num, start, len, itemID) {let batch = await getData(data_num, start, len);document.title = batch[itemID]['title'];let items = showHit(batch[itemID], '', true, null, null, {'skip': 0, 'pos': 0, 'bail': 999, 'found': 0});document.getElementById("results").replaceChildren(...items);}function notify(desc) {let searching = document.createElement('span');searching.innerText = desc;document.getElementById("results").replaceChildren(searching);}async function searchFor(search, skip=0) {if (info === null) {info = await getData(0, 0, 100, "json");batches = await getData(...info['data']);}notify("Searching...");let searchTerms = search.split(' ');let paginator = {'skip': skip,'pos': 0,'bail': 100,'found': 0,};search = {'terms': [],'before': null,'after': null,'regex': false,'logic': false,'title': false,'orig': search,};for (let word of searchTerms) {let m = word.match(/^after:([^ ]+)( |$)/i);if (m != null) {search['after'] = m[1];continue;}m = word.match(/^before:([^ ]+)( |$)/i);if (m != null) {search['before'] = m[1];continue;}m = word.match(/^(?:regex|re):([^ ]+)( |$)/i);if (m != null) {search['terms'].push(m[1]);search['regex'] = true;continue;}m = word.match(/^title:([^ ]+)( |$)/i);if (m != null) {search['terms'].push(m[1]);search['title'] = true;continue;}m = word.match(/^logic:([^ ]+)( |$)/i);if (m != null) {search['terms'].push(m[1]);search['logic'] = true;continue;}search['terms'].push(word);}if (search['terms'].join(' ') == 'list') {search['title'] = true;search['terms'] = [];paginator['bail'] = 10000;}if (search['logic']) {let debugLogic = false;let nearAmount = 200;let terms = [];let state = {negate: false, new: true};let dumpState = termsToDump => {let termsPretty = [];for (let x of termsToDump) {if (x.oper == 'HIT') {if (x.negate) {termsPretty.push("!" + x.val);} else {termsPretty.push(x.val);}} else {termsPretty.push(x.oper);}};return termsPretty.join(" ");};if (debugLogic) {console.log(`  Stack: '${search['terms'].join("', '")}'`);}for (let val of search['terms'].join(' ').replace("(", " ( ").replace(")", " ) ").split(' ')) {if (val.length > 0) {if (val.search(/^(and|or|near)$/i) == 0) {terms.push({oper: val.toUpperCase()});state.new = true;} else if (val == "(") {terms.push({oper: "OPEN"});} else if (val == ")") {terms.push({oper: "CLOSE"});} else if (val.search(/^(not)$/i) == 0) {state.new = true;state.negate = true;} else {if (state.new) {terms.push({oper: 'HIT', val: val, negate: state.negate});state.new = false;state.negate = false;} else {terms[terms.length-1].val += ' ' + val;}}}};if (debugLogic) {console.log(`  Parsed: ${dumpState(terms)}`);}let hitOrVal = x => {return (x.oper == 'HIT') || (x.oper == 'VAL')};let isTrue = (x, words) => {if (x.oper == 'VAL') {return x.val;} else if (x.oper == 'HIT') {let ret = (words.indexOf(x.val) >= 0);if (x.negate) {ret = !ret;}return ret;} else {throw new Error("Unable to parse syntax: " + JSON.stringify(x));}};let isWord = x => {return x.oper == 'HIT' && !x.negate;};let processTerms = (words, terms) => {let stack = [...terms];while (true) {let foundPair = false;let depth = 0;let openAt = -1;let i = -1;for (let x of stack) {i++;if (x.oper == 'OPEN') {if (depth == 0) {openAt = i;}depth++;} else if (x.oper == 'CLOSE') {depth--;if (depth == 0) {let temp = processTerms(words, stack.slice(openAt + 1, i));stack = stack.slice(0, openAt).concat([{oper: 'VAL', val: temp}]).concat(stack.slice(i+1));foundPair = true;break;}}};if (!foundPair) {break;}}while (stack.length > 1) {if (stack.length >= 3 && ((stack[0].oper == 'VAL' && !stack[0].val) || (stack[2].oper == 'VAL' && !stack[2].val)) && stack[1].oper == 'NEAR') {stack = [{oper: 'VAL', val: false}].concat(stack.slice(3));} else if (stack.length >= 3 && stack[0].oper == 'HIT' && stack[1].oper == 'NEAR' && stack[2].oper == 'HIT') {let locs = x => {let ret = [];let i = -1;while ((i=words.indexOf(x,i+1)) >= 0) {ret.push(i);}return ret;};let hitsA = locs(stack[0].val);let hitsB = locs(stack[2].val);let foundHit = false;for (let a of hitsA) {if (foundHit) {break;}for (let b of hitsB) {if (Math.abs(a - b) <= nearAmount) {stack = [stack[0]].concat(stack.slice(3));foundHit = true;break;}};};if (!foundHit) {stack = [{oper: 'VAL', val: false}].concat(stack.slice(3));}} else if (stack.length >= 3 && hitOrVal(stack[0]) && stack[1].oper == 'AND' && hitOrVal(stack[2])) {if (isTrue(stack[0], words) && isTrue(stack[2], words) && isWord(stack[0]) && isWord(stack[2])) {stack = [stack[0]].concat(stack.slice(3));} else {stack = [{oper: 'VAL', val: isTrue(stack[0], words) && isTrue(stack[2], words)}].concat(stack.slice(3));}} else if (stack.length >= 3 && hitOrVal(stack[0]) && stack[1].oper == 'OR' && hitOrVal(stack[2])) {if ((isTrue(stack[0], words) || isTrue(stack[2], words)) && isWord(stack[0]) && isWord(stack[2])) {if (isTrue(stack[0], words)) {stack = [stack[0]].concat(stack.slice(3));} else {stack = [stack[2]].concat(stack.slice(3));}} else {stack = [{oper: 'VAL', val: isTrue(stack[0], words) || isTrue(stack[2], words)}].concat(stack.slice(3));}} else {throw new Error("Invalid operator: " + dumpState(stack));}}if (stack.length == 1 && hitOrVal(stack[0])) {return isTrue(stack[0], words);} else {throw new Error('Invalid logic syntax: ' + dumpState(stack));}};search['logic_helper'] = words => {return processTerms(words, terms);};}let temp = [];for (let batchInfo of batches) {if (paginator['bail'] == 0) {break;}let key = batchInfo.join('|');if (!(key in batchData)) {batchData[key] = await getData(...batchInfo);}let batch = batchData[key];let itemID = -1;for (let item of batch) {itemID++;if (paginator['bail'] == 0) {break;}if (search['before'] != null) {if (item['published'] >= search['before']) {continue;}}if (search['after'] != null) {if (item['published'] <= search['after']) {continue;}}temp = temp.concat(showHit(item, search, false, batchInfo, itemID, paginator));}}if (paginator['found'] == 0) {let comment = document.createElement('span');temp.push(comment);comment.innerText = "(No matches found)";}document.getElementById("results").replaceChildren(...temp);}async function showCreation() {let info = await getData(0, 0, 100, "json");contextAfter = info['after'];contextBefore = info['before'];document.getElementById('created').innerHTML = info['created'] + " with " + info['items'] + " entries";}function cacheDataHelper(key, batchInfo) {getData(...batchInfo).then(data => {batchData[key] = data;cacheData();});}function cacheData() {if (info === null) {getData(0, 0, 100, "json").then(newInfo => {getData(...newInfo['data']).then(newBatches => {info = newInfo;batches = newBatches;cacheData();});});return;}for (let batchInfo of batches) {let key = batchInfo.join('|');if (!(key in batchData)) {setTimeout(() => {cacheDataHelper(key, batchInfo)});break;}}}document.addEventListener("DOMContentLoaded", function(event) {let info = window.location.hash.substring(1);info = info.split(",");if (info.length == 4) {document.getElementById("search_input").innerHTML = '';document.getElementById("footer").innerHTML = '';showTranscript(parseInt(info[0]), parseInt(info[1]), parseInt(info[2]), parseInt(info[3]));} else {showCreation().then(() => {document.getElementById("search").focus();cacheData();});}});function handleKey(e) {if (e.keyCode === 13) {e.preventDefault();let val = document.getElementById('search').value.trim();if (val.length > 0) {searchFor(val).then().catch(e => {notify("ERROR: " + e);});}}}</script></head><body><span id="search_input">Search term: <input id="search" type="text" size=50 autocomplete="off" autocorrect="off" onkeyup="handleKey(event);"><br><span style="font-size: 80%;">Notes:<br><div style="margin-left: 1em;">"search term" = Search for "seach term"<br>"list" = Show a list of all items<br>"... after:xxx" = Show items that are published after xxx<br>"... before:xxx" = Show items that are published before xxx<br>"regex:xxx" = Search using regular expressions<br>"logic:xxx" = Search using logic operators: AND, OR, NOT, NEAR, ()<br>"title:xxx" = Search in the titles<br></div></span><br></span><span id="results">...</span><span class="created" id="footer"><hr>Created: <span id="created">(loading)</span></span></body></html>