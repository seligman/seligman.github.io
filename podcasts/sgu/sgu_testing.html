<!DOCTYPE html>
<html lang="en">
<head>
<!--
This is a WIP as I develop a new version of this page.
There are probably functional bugs for now, but if you have
comments or thoughts on the UX, please reach out to me!
-->
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" type="image/png" sizes="16x16" href="spyglass.png"/>
<title>Search</title>
<style>
:root {
    --bg-color: #121212;
    --card-color: #1e1e1e;
    --text-color: #e0e0e0;
    --accent-color: #a0a0ff;
    --accent-hover: #c0c0ff;
    --border-color: #333333;
    --secondary-color: #2d2d2d;
    --error-color: #cf6679;
}

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    font-family: "Roboto", sans-serif;
    font-size: 12pt;
}

body {
    background-color: var(--bg-color);
    color: var(--text-color);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 2rem;
}

.created {
    font-size: 8pt;
    padding-top: 0.25em;
}
.created span {
    font-size: 8pt;
}

.container {
    width: 100%;
}

header {
    margin-bottom: 2rem;
    text-align: center;
}

h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    color: var(--accent-color);
}

.search-card {
    background-color: var(--card-color);
    border-radius: 8px;
    padding: 2rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    margin-bottom: 2rem;
}

.search-form {
    display: flex;
    flex-direction: column;
    gap: 1.2rem;
}

.search-bar {
    display: flex;
    gap: 0.5rem;
}
.search-style {
    width: auto;
    flex: 0 0 auto;
}

input[type="text"],
select {
    flex: 1;
    padding: 0.75rem 1rem;
    font-size: 1rem;
    background-color: var(--secondary-color);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    outline: none;
    transition: border-color 0.3s;
}

input[type="text"]:focus,
select:focus {
    border-color: var(--accent-color);
}

select {
    cursor: pointer;
    appearance: none;
    padding-right: 2rem;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23e0e0e0' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 0.7rem center;
    background-size: 1rem;
}

button {
    padding: 0.75rem 1.5rem;
    font-size: 1rem;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
}

button:hover {
    background-color: var(--accent-hover);
}

.search-options {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
}

.option-group {
    flex: 1;
    min-width: 200px;
}

.option-label {
    font-size: 0.9rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
    display: block;
    color: var(--accent-color);
}

.time-inputs {
    display: flex;
    gap: 1rem;
}

.time-input {
    flex: 1;
}

.time-input input {
    width: 100%;
}

.checkbox-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-top: 0.5rem;
}

input[type="checkbox"] {
    appearance: none;
    width: 18px;
    height: 18px;
    border: 2px solid var(--border-color);
    border-radius: 3px;
    background-color: var(--secondary-color);
    cursor: pointer;
    position: relative;
}

input[type="checkbox"]:checked {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
}

input[type="checkbox"]:checked::after {
    content: "";
    position: absolute;
    left: 5px;
    top: 2px;
    width: 5px;
    height: 10px;
    border: solid white;
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
}

.results-container {
    background-color: var(--card-color);
    border-radius: 8px;
    padding: 1.5rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.results-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 0.75rem;
    border-bottom: 1px solid var(--border-color);
}

.result-stats {
    font-size: 0.9rem;
    color: #999;
}

.result-sort {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.result-sort select {
    padding: 0.5rem;
    font-size: 0.9rem;
}

.result-item {
    padding: 1.2rem;
    border-bottom: 1px solid var(--border-color);
}

.result-item:last-child {
    border-bottom: none;
}

.result-title {
    font-size: 1.2rem;
    margin-bottom: 0.5rem;
    color: var(--accent-color);
}

.result-title a {
    color: var(--accent-color);
    text-decoration: none;
}

.result-title a:hover {
    text-decoration: underline;
}

.result-url {
    font-size: 0.8rem;
    color: #999;
    margin-bottom: 0.75rem;
}

.result-description {
    font-size: 0.95rem;
    line-height: 1.5;
}

.result-meta {
    display: flex;
    gap: 1rem;
    margin-top: 0.75rem;
    font-size: 0.8rem;
    color: #999;
}

.pagination {
    display: flex;
    justify-content: center;
    margin-top: 2rem;
    gap: 0.5rem;
}

.page-btn {
    padding: 0.5rem 1rem;
    background-color: var(--secondary-color);
    color: var(--text-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s;
}

.page-btn:hover:not(.active) {
    background-color: #333;
}

.page-btn.active {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
}

.quick-links {
    display: flex;
    gap: 1.5rem;
    margin-top: 1.2rem;
}

.quick-link {
    color: var(--accent-color);
    text-decoration: none;
    font-size: 0.95rem;
    position: relative;
    transition: color 0.2s;
}

.quick-link:hover {
    color: var(--accent-hover);
    text-decoration: underline;
}

.quick-link::after {
    content: "â†’";
    position: relative;
    display: inline-block;
    margin-left: 4px;
    transition: transform 0.2s;
}

.quick-link:hover::after {
    transform: translateX(3px);
}

@media (max-width: 768px) {
    .search-bar {
        flex-direction: column;
    }
    
    .search-options {
        flex-direction: column;
        gap: 1rem;
    }
    
    .option-group {
        width: 100%;
    }
}

.hit {
    margin-bottom: 0.5em;
    line-height: 125%;
    text-indent: -2em;
    margin-left: 2em;
}
</style>
</head>
<body>
<div class="container">
    <div class="search-card">
        <form class="search-form">
            <div class="search-bar">
                <select aria-label="Search style" id="search_type" class="search-style">
                    <option value="raw">Use this exact string:</option>
                    <option value="regex">Use regular expressions:</option>
                    <option value="logic">Use logic ops (AND, OR, NOT, NEAR, WHOLE):</option>
                    <option value="title">Use titles only:</option>
                </select>
                <input id="search" type="text" placeholder="Enter your search query..." aria-label="Search query">
                <button type="submit">Search</button>
            </div>
            
            <div class="search-options">
                <div class="option-group">
                    <label class="option-label">Time Range</label>
                    <div class="time-inputs">
                        <div class="time-input">
                            <input id="start" type="text" placeholder="Start date" aria-label="Start date">
                        </div>
                        <div class="time-input">
                            <input id="end" type="text" placeholder="End date" aria-label="End date">
                        </div>
                    </div>
                </div>
                
                <div class="option-group">
                    <label class="option-label">Options</label>
                    <div class="checkbox-group">
                        <input type="checkbox" id="reverse" aria-label="Results start with newest first">
                        <label for="reverse">Results start with newest first</label>
                    </div>
                </div>
            </div>

            <div class="quick-links">
                <a href="#" class="quick-link" id="show_all">Show all episodes</a>
                <a href="#" class="quick-link" id="show_latest">Show latest episodes</a>
            </div>
        </form>
    </div>
    
    <div class="results-container">
        <div class="results-header">
            <div class="result-stats" id="totalsCount">...</div>
        </div>
        
        <div class="results-list" id="results"></div>
        
        <div class="created" id="footer">Created: <span id="created">(loading)</span></div>
    </div>
</div>
    
<script>
document.querySelectorAll('.page-btn').forEach(button => {
    button.addEventListener('click', () => {
        document.querySelector('.page-btn.active').classList.remove('active');
        button.classList.add('active');
    });
});

document.querySelector('form').addEventListener('submit', (e) => {
    e.preventDefault();
    let val = document.getElementById("search").value;
    searchFor(val).then().catch(e => {
        notify("ERROR: " + e);
    });
});

let contextBefore = 5;
let contextAfter = 500;
let totalItems = 0;
let info = null;
let batches = null;
let batchData = {};

async function getData(data_num, start, len, loadMode='gzipDecode') {
    const resp = await fetch(
        "./search_data_" + String(data_num).padStart(2, '0') + ".dat", 
        {
            'headers': {
                'Range': 'bytes=' + start + "-" + (start + len - 1),
            },
        },
    );
    if (loadMode == 'gzipDecode') {
        const blob = await resp.blob();
        const ds = new DecompressionStream("gzip");
        const decomp = blob.stream().pipeThrough(ds);
        const decoded = await new Response(decomp).blob();
        const text = await decoded.text();
        const parsed = JSON.parse(text);
        return parsed;
    } else if (loadMode == 'json') {
        const text = await resp.text();
        const parsed = JSON.parse(text);
        return parsed;
    }
}

function escapeRe(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function showHit(item, search, showAll, batch, itemID, paginator, countOnly) {
    let ret = [];
    let lastHit = 0;
    
    let findHits = handler => {
        let words = item[search.title ? 'title' : 'words'].toLowerCase();
        let parseItem = true;

        if (search.hasOwnProperty("groups") && search.groups.length > 0) {
            parseItem = false;
            for (let x of search.groups) {
                if (x == item['group']) {
                    parseItem = true;
                }
            }
        }

        if (parseItem) {
            if (showAll || search.title) {
                handler(0, 0);
            } else if (search.regex) {
                let target = search.terms.join(' ');
                target = new RegExp(target, 'gi');
                while (true) {
                    let hit = target.exec(words);
                    if (hit == null) {
                        break;
                    }
                    if (!handler(hit.index, hit[0].length)) {
                        break;
                    }
                }
            } else if (search.logic) {
                let lastHit = -1;
                while (true) {
                    let temp = search.logicFunc(words.slice(lastHit + 1));
                    if (!temp[0]) {
                        break;
                    }
                    if (!handler(lastHit + 1 + temp[1], temp[2] - temp[1] + 1)) {
                        break;
                    }
                    lastHit += temp[2];
                }
            } else {
                let target = search.terms.join(' ');
                target = target.split('').map(x=>escapeRe(x)+'-?').join('');
                target = RegExp(target, 'gi');
                while (true) {
                    let hit = target.exec(words);
                    if (hit == null) {
                        break;
                    }
                    if (!handler(hit.index, hit[0].length)) {
                        break;
                    }
                }
            }
        }
    };

    let lookup = null;
    let start = null;
    let speaker = null;
    let speakerPop = null;
    let counts = null;
    let hitCounts = [];

    let extra = '';
    if (window.location.hash.substring(1, 5) == "rid=") {
        extra = atob(window.location.hash.substring(5));
    }

    let showHit = (hitAt, hitLen) => {
        if (paginator.skip > 0) {
            paginator.skip--;
        } else if (countOnly) {
            paginator.bail--;
            paginator.found++;
            hitCounts.push(0);
            if (hitCounts.length == 1) {
                paginator.foundTitles++;
            }
        } else {
            let hit = document.createElement("div");
            hit.className = "result-item";
            ret.push(hit);

            let header = document.createElement("h3")
            header.className = "result-title";
            hit.appendChild(header);

            let link = document.createElement("a");
            header.appendChild(link);
            link.href = item.link;
            link.target = "_blank";
            link.innerText = (item.published == '1970-01-01' ? '' : (item.published + ": ")) + item.title;

            console.log(search.title);
            let info = document.createElement("p");
            info.className = "result-description";
            hit.appendChild(info);

            // let hit = document.createElement((search.title) ? "div": "p");
            // if (search.title) {
            //     hit.className = 'item';
            // }
            // ret.push(hit);
            // let header;
            // if (search.title) {
            //     link = document.createElement("a");
            //     hit.appendChild(link);
            //     header = hit;
            // } else {
            //     header = document.createElement("h1");
            //     hit.appendChild(header);
            //     link = document.createElement("a");
            //     header.appendChild(link);
            //     header.className = "title";
            // }
            // link.href = item.link;
            // link.target = "_blank";
            // link.innerText = (item.published == '1970-01-01' ? '' : (item.published + ": ")) + item.title;
            if (batch !== null) {
                let span = document.createElement("span");
                header.appendChild(span);
                span.innerText = " ";
                let fullLink = document.createElement("a");
                header.appendChild(fullLink);
                let count = document.createElement("span");
                header.appendChild(count);
                hitCounts.push(count);
                if (hitCounts.length == 1) {
                    paginator.foundTitles++;
                }
                fullLink.className = "transcriptLink";
                fullLink.innerText = "[transcript]";
                fullLink.target = "_blank";
                if (extra.length > 0 && 'remote' in item) { 
                    fullLink.href = extra + item.remote + ".html";
                    if (!search.title) {
                        fullLink.href += "#" + start[hitAt] * 10;
                    }
                } else {
                    fullLink.href = "#" + batch[0] + "," + batch[1] + "," + batch[2] + "," + itemID;
                    if (!search.title) {
                        fullLink.href += "," + start[hitAt];
                    }
                }
            }
            
            if (!search.title) {
                let lastSpeaker = '';
                let phraseStartAt = 0;
                let startAt = -1;
                let phrase = null;
                let endedSentence = false;
                for (let i = Math.max(0, hitAt - contextBefore); i <= (showAll ? (start.length - 1) : Math.min(hitAt + 1 + contextAfter, start.length - 1)); i++) {
                    if (!showAll) {
                        if (startAt >= 0 && ((start[i] / 100) - startAt) > 60) {
                            break;
                        }
                    }
                    let curSpeaker = "";
                    if (phrase === null || (endedSentence && (lastSpeaker != speaker[i] || (start[i] - phraseStartAt) >= 45)) || (start[i] - phraseStartAt) >= 120) {
                        if (lastSpeaker != speaker[i]) {
                            curSpeaker = speakerPop[speaker[i]];
                        }
                        lastSpeaker = speaker[i];
                        phraseStartAt = start[i];
                        if (startAt === -1) {
                            startAt = phraseStartAt;
                        }
                        
                        let text = document.createElement('p');
                        hit.appendChild(text);
                        text.className = "hit";
                        let time = document.createElement('span');
                        text.appendChild(time);
                        let at = start[i];
                        let val = "";
                        val += Math.floor(at / 3600).toString() + ":";
                        val += (Math.floor(at / 60) % 60).toString().padStart(2, "0") + ":";
                        val += (at % 60).toString().padStart(2, "0") + ":";
                        time.innerText = val;
                        phrase = document.createElement('span');
                        text.appendChild(phrase);
                    }

                    let curWord = item.words.slice(lookup.word[i], lookup.word[i+1]-1);
                    let wordElem = document.createElement('span');
                    wordElem.at = start[i];
                    if (!showAll) {
                        if (i >= hitAt && i <= hitLen) {
                            wordElem.className = "target";
                        }
                    }
                    wordElem.innerText = curSpeaker + " " + curWord;
                    phrase.appendChild(wordElem);
                    curSpeaker = "";
                    endedSentence = ".?!".includes(curWord.slice(-1));
                }
            }

            paginator.bail--;
            paginator.found++;
        }
        paginator.pos++;
        if (showAll) {
            return false;
        }
        if (paginator.bail == 0) {
            let comment = document.createElement('span');
            ret.push(comment);
            comment.innerText = "View next page...";
            comment.className = "clickable";
            comment.onclick = () => {
                window.scrollTo(0, 0);
                searchFor(search.orig, paginator.pos).then();
            };
            return false;
        }
        return true;
    };

    findHits((hit, size) => {
        if (lookup == null) {
            lookup = {pos: [], word: []};
            if (!search.title) {
                let wordNum = -1;
                let off = 0;
                let wasSpace = true;
                for (let x of item.words) {
                    if (wasSpace) {
                        wordNum++;
                        lookup.word.push(off);
                    }
                    wasSpace = (x == ' ');
                    lookup.pos.push(wordNum);
                    off++;
                }
                lookup.word.push(off+1);

                let last = 0;
                start = [];
                for (let cur of item.start) {
                    last += cur;
                    start.push(last);
                }

                speakerPop = {};
                speaker = item.speaker.split('');
                counts = {};
                speaker.map(x => {
                    counts[x] = counts[x] ? counts[x] + 1 : 1;
                });
                counts["@"] = 0;
                counts = Object.entries(counts);
                counts.sort((a, b) => {
                    if (b < a) {
                        return -1;
                    }
                    if (a > b) {
                        return 1;
                    }
                    return 0;
                });
                counts.map(x => {
                    if (x[0] == "@") {
                        speakerPop[x[0]] = '';
                    } else {
                        speakerPop[x[0]] = ' ' + String.fromCharCode("A".charCodeAt(0) + Object.keys(speakerPop).length) + ": ";
                    }
                });
            }
        }

        if (!showHit(lookup.pos[hit], lookup.pos[hit+size])) {
            return false;
        }
        return true;
    });

    return ret;
}

async function showTranscript(data_num, start, len, itemID) {
    let batch = await getData(data_num, start, len);
    document.title = batch[itemID].title;
    let items = showHit(batch[itemID], '', true, null, null, {skip: 0, pos: 0, bail: 9999, found: 0});
    document.getElementById("results").replaceChildren(...items);
}

function notify(desc) {
    let searching = document.createElement('span');
    searching.innerText = desc;
    document.getElementById("results").replaceChildren(searching);
}

async function searchFor(search, skip=0, countOnly=false, showLatest=false, showAll=false) {
    if (info === null) {
        info = await getData(0, 0, 100, "json");
        batches = await getData(...info.data);
    }

    if (!countOnly) {
        notify("Searching...");
    }

    let searchTerms = search.split(' ');
    let paginator = {
        skip: skip, 
        pos: 0, 
        bail: countOnly ? 100000 : 100, 
        found: 0,
        foundTitles: 0,
    };
    search = {
        terms: [],
        before: null,
        after: null,
        regex: false,
        logic: false,
        title: false,
        reverse: false,
        groups: [],
        orig: search,
    };

    if (document.getElementById("start").value.length > 0) {
        search.after = document.getElementById("start").value;
    }

    if (document.getElementById("end").value.length > 0) {
        search.before = document.getElementById("end").value;
    }

    if (document.getElementById("search_type").value == "regex") {
        search.regex = true;
    } else if (document.getElementById("search_type").value == "logic") {
        search.logic = true;
    } else if (document.getElementById("search_type").value == "title") {
        search.title = true;
    }

    if (document.getElementById("reverse").checked) {
        search.reverse = true;
    }

    for (let word of searchTerms) {
        let m = word.match(/^group:([^ ]+)( |$)/i);
        if (m != null) {
            search.groups.push(m[1]);
            continue;
        }

        search.terms.push(word);
    }

    if (showAll) {
        search.title = true;
        search.terms = [];
        paginator.bail = 100000;
    } else if (showLatest) {
        search.title = true;
        search.terms = [];
        paginator.skip = Math.max(0, totalItems - 25);
        paginator.bail = 10000;
        search.after = null;
        search.before = null;
    } else if (search.logic) {
        let debugLogic = false;
        let nearAmount = 200;
        /* ########################################################################################################################################## */
        let terms = [];
        let state = {negate: false, new: true};
        let dumpState = termsToDump => {
            let termsPretty = [];
            for (let x of termsToDump) {
                if (x.oper == 'HIT') {
                    if (x.negate) {
                        termsPretty.push("!" + x.val);
                    } else {
                        termsPretty.push(x.val);
                    }
                } else {
                    termsPretty.push(x.oper);
                }
            };
            return termsPretty.join(" ");
        };
        if (debugLogic) {
            console.log(`  Stack: '${search.terms.join("', '")}'`);
        }
        let isWhole = false;
        for (let val of search.terms.join(' ').replace("(", " ( ").replace(")", " ) ").split(' ')) {
            if (val.length > 0) {
                if (val.search(/^(and|or|near)$/i) == 0) {
                    terms.push({oper: val.toUpperCase()});
                    state.new = true;
                } else if (val.search(/^(whole)$/i) == 0) {
                    isWhole = true;
                } else if (val == "(") {
                    terms.push({oper: "OPEN"});
                } else if (val == ")") {
                    terms.push({oper: "CLOSE"});
                } else if (val.search(/^(not)$/i) == 0) {
                    state.new = true;
                    state.negate = true;
                } else {
                    if (state.new) {
                        terms.push({whole: isWhole, oper: 'HIT', val: val, negate: state.negate});
                        state.new = false;
                        state.negate = false;
                    } else {
                        terms[terms.length-1].val += ' ' + val;
                    }
                }
            }
        };
        if (debugLogic) {
            console.log(`  Parsed: ${dumpState(terms)}`);
        }

        let hitOrVal = x => {
            /* Just see if an item is a hit or a val */
            return (x.oper == 'HIT') || (x.oper == 'VAL')
        };

        let isTrue = (x, words) => {
            /* See if an item is a True bool, or a hit that matches */
            if (x.oper == 'VAL') {
                return x.val;
            } else if (x.oper == 'HIT') {
                let ret;
                if (x.whole) {
                    ret = words.search(new RegExp("\\b" + x.val.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&') + "\\b")) >= 0;
                } else {
                    ret = (words.indexOf(x.val) >= 0);
                }
                if (x.negate) {
                    ret = !ret;
                }
                return ret;
            } else {
                throw new Error("Unable to parse syntax: " + JSON.stringify(x));
            }
        };

        let isWord = x => {
            /* See if an item is a positive hit */
            return x.oper == 'HIT' && !x.negate;
        };

        let range = (words, x, y, dest) => {
            /* Get extend of begin and end */

            if (x !== null) {
                if (x.oper == 'HIT' && x.begin == undefined && !x.negate) {
                    let temp = words.indexOf(x.val);
                    if (temp >= 0) {
                        x.begin = temp;
                        x.end = temp + x.val.length;
                    }
                }
            }

            if (y !== null) {
                if (y.oper == 'HIT' && y.begin == undefined && !y.negate) {
                    let temp = words.indexOf(y.val);
                    if (temp >= 0) {
                        y.begin = temp;
                        y.end = temp + y.val.length;
                    }
                }
            }

            if (x != null && y != null && x.begin != undefined && y.begin != undefined) {
                dest.begin = Math.min(x.begin, y.begin);
            } else if (x != null && x.begin != undefined) {
                dest.begin = x.begin;
            } else if (y != null && y.begin != undefined) {
                dest.begin = y.begin;
            }

            if (x != null && y != null && x.begin != undefined && y.begin != undefined) {
                dest.end = Math.max(x.end, y.end);
            } else if (x != null && x.begin != undefined) {
                dest.end = x.end;
            } else if (y != null && y.begin != undefined) {
                dest.end = y.end;
            }
        };

        let processTerms = (words, terms) => {
            let stack = [...terms];
            for (let cur of stack) {
                cur.begin = undefined;
                cur.end = undefined;
            }

            while (true) {
                /* Find and resolve parens */
                let foundPair = false;
                let depth = 0;
                let openAt = -1;
                let i = -1;
                for (let x of stack) {
                    i++;
                    if (x.oper == 'OPEN') {
                        if (depth == 0) {
                            openAt = i;
                        }
                        depth++;
                    } else if (x.oper == 'CLOSE') {
                        depth--;
                        if (depth == 0) {
                            /* Found an open and matching close, process the contents */
                            let temp = processTerms(words, stack.slice(openAt + 1, i));
                            stack = stack.slice(0, openAt).concat([{oper: 'VAL', val: temp[0], begin: temp[1], end: temp[2]}]).concat(stack.slice(i+1));
                            foundPair = true;
                            break;
                        }
                    }
                };
                if (!foundPair) {
                    break;
                }
            }
            while (stack.length > 1) {
                if (stack.length >= 3 && ((stack[0].oper == 'VAL' && !stack[0].val) || (stack[2].oper == 'VAL' && !stack[2].val)) && stack[1].oper == 'NEAR') {
                    /* x NEAR x, where one of the x is False */
                    stack = [{oper: 'VAL', val: false}].concat(stack.slice(3));
                } else if (stack.length >= 3 && stack[0].oper == 'HIT' && stack[1].oper == 'NEAR' && stack[2].oper == 'HIT') {
                    /* x NEAR x, where both of the x are hit */

                    let findMatch = (words, x, off) => {
                        if (stack[0].whole) {
                            let ret = words.slice(off).search(new RegExp("\\b" + x.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&') + "\\b"));
                            if (ret >= 0) {
                                return ret + off;
                            } else {
                                return ret;
                            }
                        } else {
                            return words.indexOf(x, off);
                        }
                    };

                    /* Find all the possible hits */
                    let locs = x => {
                        let ret = [];
                        let i = -1;
                        while ((i=findMatch(words,x,i+1)) >= 0) {
                            ret.push(i);
                        }
                        return ret;
                    };
                    let nears = 0;
                    let hits = [locs(stack[0].val)];
                    while (stack.length >= (2 * (nears + 1)) && stack[1 + nears * 2].oper == 'NEAR' && stack[2 + nears * 2].oper == 'HIT') {
                        hits.push(locs(stack[nears * 2 + 2].val));
                        nears++;
                    }
                    let allGood = true;
                    let pos = [];
                    for (let a of hits[0]) {
                        allGood = true;
                        pos = [a];
                        for (let other of hits.slice(1)) {
                            let found = false;
                            for (let b of other) {
                                if (Math.abs(a - b) <= nearAmount) {
                                    pos.push(b);
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                allGood = false;
                                break;
                            }
                        }
                        if (allGood) {
                            break;
                        }
                    }
                    if (allGood) {
                        stack = [stack[0]].concat(stack.slice(2 * nears + 1));
                        stack[0].begin = Math.min(...pos);
                        stack[0].end = Math.max(...pos);
                    } else {
                        stack = [{oper: 'VAL', val: false}].concat(stack.slice(2 * nears + 1));
                    }

                } else if (stack.length >= 3 && hitOrVal(stack[0]) && stack[1].oper == 'AND' && hitOrVal(stack[2])) {
                    /* x AND x */
                    if (isTrue(stack[0], words) && isTrue(stack[2], words) && isWord(stack[0]) && isWord(stack[2])) {
                        range(words, stack[0], stack[2], stack[0]);
                        stack = [stack[0]].concat(stack.slice(3));
                    } else {
                        let temp = {};
                        range(words, stack[0], stack[2], temp);
                        stack = [{oper: 'VAL', val: isTrue(stack[0], words) && isTrue(stack[2], words)}].concat(stack.slice(3));
                        range(words, temp, temp, stack[0]);
                    }
                } else if (stack.length >= 3 && hitOrVal(stack[0]) && stack[1].oper == 'OR' && hitOrVal(stack[2])) {
                    /* x OR x */
                    if ((isTrue(stack[0], words) || isTrue(stack[2], words)) && isWord(stack[0]) && isWord(stack[2])) {
                        if (isTrue(stack[0], words)) {
                            stack = [stack[0]].concat(stack.slice(3));
                        } else {
                            stack = [stack[2]].concat(stack.slice(3));
                        }
                    } else {
                        stack = [{oper: 'VAL', val: isTrue(stack[0], words) || isTrue(stack[2], words)}].concat(stack.slice(3));
                    }
                } else {
                    throw new Error("Invalid operator: " + dumpState(stack));
                }
            }

            if (stack.length == 1 && hitOrVal(stack[0])) {
                range(words, stack[0], stack[0], stack[0]);
                return [isTrue(stack[0], words), stack[0].begin, stack[0].end];
            } else {
                throw new Error('Invalid logic syntax: ' + dumpState(stack));
            }
        };

        search.logicFunc = words => {
            return processTerms(words, terms);
        };
        /* ########################################################################################################################################## */
    }

    let temp = [];
    let batchesTemp = batches;
    if (search.reverse) {
        batchesTemp = [...batchesTemp].reverse();
    }
    for (let batchInfo of batchesTemp) {
        if (paginator.bail == 0) {
            break;
        }
        let key = batchInfo.join('|');
        if (!(key in batchData)) {
            batchData[key] = await getData(...batchInfo);
        }
        let batch = batchData[key];
        let itemID = -1;
        let batchTemp = batch;
        if (search.reverse) {
            batchTemp = [...batchTemp].reverse();
        }
        for (let item of batchTemp) {
            itemID++;
            if (paginator.bail == 0) {
                break;
            }

            if (search.before != null) {
                if (item.published >= search.before) {
                    continue;
                }
            }
            if (search.after != null) {
                if (item.published <= search.after) {
                    continue;
                }
            }

            temp = temp.concat(showHit(item, search, false, batchInfo, itemID, paginator, countOnly));
        }
    }

    if (countOnly) {
        document.getElementById("totalsCount").innerText = 
            `Found ${paginator.bail == 0 ? 'at least ' : ''}${commafy(paginator.found)} hits in ${commafy(paginator.foundTitles)} episodes`;
    } else {
        if (!search.title) {
            if (paginator.found == 0) {
                let comment = document.getElementById("totalsCount");
                // let comment = document.createElement('span');
                // temp.push(comment);
                comment.innerText = "(No matches found)";
            } else {
                let comment = document.getElementById("totalsCount");
                // let comment = document.createElement('span');
                // temp.unshift(comment);
                comment.innerText = `Found ${paginator.bail == 0 ? 'at least ' : ''}${commafy(paginator.found)} hits in ${commafy(paginator.foundTitles)} episodes`;
                if (paginator.bail == 0) {
                    // comment.id = "totalsCount";
                    let keep = document.createElement("span");
                    keep.className = "clickable";
                    keep.innerText = ", produce complete count.";
                    keep.onclick = () => {
                        searchFor(search.orig, 0, true).then();

                    };
                    comment.appendChild(keep);
                }
            }
        }

        document.getElementById("results").replaceChildren(...temp);
    }
}


function commafy(val) {
    return val.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

async function showCreation() {
    let info = await getData(0, 0, 100, "json");
    contextAfter = info.after;
    contextBefore = info.before;
    document.getElementById('created').innerHTML = `${info.created} with ${commafy(info.items)} entries`;
    totalItems = info.items;
}

function cacheData(workers, startAt) {
    if (info === null) {
        getData(0, 0, 100, "json").then(newInfo => {
            getData(...newInfo.data).then(newBatches => {
                info = newInfo;
                batches = newBatches;
                for (let i = 0; i < workers; i++) {
                    cacheData(workers, i);
                }
            });
        });
        return;
    }

    if (startAt < batches.length) {
        let key = batches[startAt].join('|');
        if (!(key in batchData)) {
            getData(...batches[startAt]).then(data => {
                batchData[key] = data;
                cacheData(workers, startAt + workers);
            });
        }
    }
}

document.addEventListener("DOMContentLoaded", function(event) {
    if (window.location.hash.substring(1, 5) == "rid=") {
        let temp = document.getElementById("info");
        if (temp != null) {
            temp.src = temp.src.replace(".png", "-rid.png");
        }
    }

    document.getElementById("show_all").addEventListener('click', e => {
        e.preventDefault();
        searchFor("", 0, false, false, true).then();
    });
    document.getElementById("show_latest").addEventListener('click', e => {
        e.preventDefault();
        searchFor("", 0, false, true, false).then();
    });

    let info = window.location.hash.substring(1);
    info = info.split(",");
    if (info.length == 4 || info.length == 5) {
        document.getElementById("search_input").innerHTML = '';
        document.getElementById("footer").innerHTML = '';
        showTranscript(parseInt(info[0]), parseInt(info[1]), parseInt(info[2]), parseInt(info[3])).then(() => {
            if (info.length == 5) {
                let at = parseInt(info[4]);
                for (let cur of document.getElementsByTagName("span")) {
                    if (cur.at >= at) {
                        cur.scrollIntoView();
                        break;
                    }
                }
            }
        });
    } else {
        showCreation().then(() => {
            document.getElementById("search").focus();
            cacheData(4, 0);
        });
    }
});

function handleKey(e) {
    if (e.keyCode === 13) {
        e.preventDefault();
        let val = document.getElementById('search').value.trim();
        if (val.length > 0) {
            searchFor(val).then().catch(e => {
                notify("ERROR: " + e);
            });
        }
    }
}

</script>
</body>
</html>

<!--
<!DOCTYPE html>
<html><head>
<meta charset="utf-8"/>
<link rel="icon" type="image/png" sizes="16x16" href="spyglass.png"/>
<title>Search</title>
<style>
:root {
    color-scheme: dark;
}
html,
body {
    background-color: #333;
    color: #ccc;
    font-family: "Roboto", sans-serif;
    font-size: 12pt;
}
a {
    color: #ccf;
    text-decoration: none;
}
.clickable {
    cursor: pointer;
    color: #ccf;
}
.clickable:hover {
    text-decoration: underline;
}
.transcriptLink {
    font-size: 80%;
    font-weight: normal;
}
h1 {
    padding-left: 0.5em;
    margin-top: 1.5em;
    margin-bottom: 0.25em;
    border-bottom: 1px solid #777;
    font-size: 14pt;
    color: #888;
}
.item {
    padding-bottom: 0.25em;
}
ul {
    list-style-type: none;
}
li {
    margin-bottom: 0.5em;
}
a:hover {
    color: #ccf;
    text-decoration: underline;
}
.title {
    font-weight: bold;
    border-bottom-style: solid;
    border-bottom-width: 1px;
    border-bottom-color: #888;
    padding-left: 1em;
    padding-bottom: 0;
    margin: 0;
    font-size: 12pt;
}
.hit {
    text-indent: -2em;
    margin-left: 2em;
}
.created {
    font-size: 8pt;
}
.target {
    background-color: #44c;
    color: #fff;
}
input[type="text"] {
    background-color: #000;
    color: #cec;
    border-top-style: hidden;
    border-right-style: hidden;
    border-left-style: hidden;
    border-bottom-style: solid;
    border-bottom-width: 1px;
    border-bottom-color: #a8a8f2;
    padding: 2px;
    outline: none;
    font-size: 12pt;
}
</style>
<script>
let contextBefore = 5;
let contextAfter = 500;
let totalItems = 0;
let info = null;
let batches = null;
let batchData = {};

async function getData(data_num, start, len, loadMode='gzipDecode') {
    const resp = await fetch(
        "./search_data_" + String(data_num).padStart(2, '0') + ".dat", 
        {
            'headers': {
                'Range': 'bytes=' + start + "-" + (start + len - 1),
            },
        },
    );
    if (loadMode == 'gzipDecode') {
        const blob = await resp.blob();
        const ds = new DecompressionStream("gzip");
        const decomp = blob.stream().pipeThrough(ds);
        const decoded = await new Response(decomp).blob();
        const text = await decoded.text();
        const parsed = JSON.parse(text);
        return parsed;
    } else if (loadMode == 'json') {
        const text = await resp.text();
        const parsed = JSON.parse(text);
        return parsed;
    }
}

function escapeRe(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function showHit(item, search, showAll, batch, itemID, paginator, countOnly) {
    let ret = [];
    let lastHit = 0;
    
    let findHits = handler => {
        let words = item[search.title ? 'title' : 'words'].toLowerCase();
        let parseItem = true;

        if (search.hasOwnProperty("groups") && search.groups.length > 0) {
            parseItem = false;
            for (let x of search.groups) {
                if (x == item['group']) {
                    parseItem = true;
                }
            }
        }

        if (parseItem) {
            if (showAll || search.title) {
                handler(0, 0);
            } else if (search.regex) {
                let target = search.terms.join(' ');
                target = new RegExp(target, 'gi');
                while (true) {
                    let hit = target.exec(words);
                    if (hit == null) {
                        break;
                    }
                    if (!handler(hit.index, hit[0].length)) {
                        break;
                    }
                }
            } else if (search.logic) {
                let lastHit = -1;
                while (true) {
                    let temp = search.logicFunc(words.slice(lastHit + 1));
                    if (!temp[0]) {
                        break;
                    }
                    if (!handler(lastHit + 1 + temp[1], temp[2] - temp[1] + 1)) {
                        break;
                    }
                    lastHit += temp[2];
                }
            } else {
                let target = search.terms.join(' ');
                target = target.split('').map(x=>escapeRe(x)+'-?').join('');
                target = RegExp(target, 'gi');
                while (true) {
                    let hit = target.exec(words);
                    if (hit == null) {
                        break;
                    }
                    if (!handler(hit.index, hit[0].length)) {
                        break;
                    }
                }
            }
        }
    };

    let lookup = null;
    let start = null;
    let speaker = null;
    let speakerPop = null;
    let counts = null;
    let hitCounts = [];

    let extra = '';
    if (window.location.hash.substring(1, 5) == "rid=") {
        extra = atob(window.location.hash.substring(5));
    }

    let showHit = (hitAt, hitLen) => {
        if (paginator.skip > 0) {
            paginator.skip--;
        } else if (countOnly) {
            paginator.bail--;
            paginator.found++;
            hitCounts.push(0);
            if (hitCounts.length == 1) {
                paginator.foundTitles++;
            }
        } else {
            let hit = document.createElement((search.title) ? "div": "p");
            if (search.title) {
                hit.className = 'item';
            }
            ret.push(hit);
            let header;
            if (search.title) {
                link = document.createElement("a");
                hit.appendChild(link);
                header = hit;
            } else {
                header = document.createElement("h1");
                hit.appendChild(header);
                link = document.createElement("a");
                header.appendChild(link);
                header.className = "title";
            }
            link.href = item.link;
            link.target = "_blank";
            link.innerText = (item.published == '1970-01-01' ? '' : (item.published + ": ")) + item.title;
            if (batch !== null) {
                let span = document.createElement("span");
                header.appendChild(span);
                span.innerText = " ";
                let fullLink = document.createElement("a");
                header.appendChild(fullLink);
                let count = document.createElement("span");
                header.appendChild(count);
                hitCounts.push(count);
                if (hitCounts.length == 1) {
                    paginator.foundTitles++;
                }
                fullLink.className = "transcriptLink";
                fullLink.innerText = "[transcript]";
                fullLink.target = "_blank";
                if (extra.length > 0 && 'remote' in item) { 
                    fullLink.href = extra + item.remote + ".html";
                    if (!search.title) {
                        fullLink.href += "#" + start[hitAt] * 10;
                    }
                } else {
                    fullLink.href = "#" + batch[0] + "," + batch[1] + "," + batch[2] + "," + itemID;
                    if (!search.title) {
                        fullLink.href += "," + start[hitAt];
                    }
                }
            }
            
            if (!search.title) {
                let lastSpeaker = '';
                let phraseStartAt = 0;
                let startAt = -1;
                let phrase = null;
                let endedSentence = false;
                for (let i = Math.max(0, hitAt - contextBefore); i <= (showAll ? (start.length - 1) : Math.min(hitAt + 1 + contextAfter, start.length - 1)); i++) {
                    if (!showAll) {
                        if (startAt >= 0 && ((start[i] / 100) - startAt) > 60) {
                            break;
                        }
                    }
                    let curSpeaker = "";
                    if (phrase === null || (endedSentence && (lastSpeaker != speaker[i] || (start[i] - phraseStartAt) >= 45)) || (start[i] - phraseStartAt) >= 120) {
                        if (lastSpeaker != speaker[i]) {
                            curSpeaker = speakerPop[speaker[i]];
                        }
                        lastSpeaker = speaker[i];
                        phraseStartAt = start[i];
                        if (startAt === -1) {
                            startAt = phraseStartAt;
                        }
                        
                        let text = document.createElement('p');
                        hit.appendChild(text);
                        text.className = "hit";
                        let time = document.createElement('span');
                        text.appendChild(time);
                        let at = start[i];
                        let val = "";
                        val += Math.floor(at / 3600).toString() + ":";
                        val += (Math.floor(at / 60) % 60).toString().padStart(2, "0") + ":";
                        val += (at % 60).toString().padStart(2, "0") + ":";
                        time.innerText = val;
                        phrase = document.createElement('span');
                        text.appendChild(phrase);
                    }

                    let curWord = item.words.slice(lookup.word[i], lookup.word[i+1]-1);
                    let wordElem = document.createElement('span');
                    wordElem.at = start[i];
                    if (!showAll) {
                        if (i >= hitAt && i <= hitLen) {
                            wordElem.className = "target";
                        }
                    }
                    wordElem.innerText = curSpeaker + " " + curWord;
                    phrase.appendChild(wordElem);
                    curSpeaker = "";
                    endedSentence = ".?!".includes(curWord.slice(-1));
                }
            }

            paginator.bail--;
            paginator.found++;
        }
        paginator.pos++;
        if (showAll) {
            return false;
        }
        if (paginator.bail == 0) {
            let comment = document.createElement('span');
            ret.push(comment);
            comment.innerText = "View next page...";
            comment.className = "clickable";
            comment.onclick = () => {
                window.scrollTo(0, 0);
                searchFor(search.orig, paginator.pos).then();
            };
            return false;
        }
        return true;
    };

    findHits((hit, size) => {
        if (lookup == null) {
            lookup = {pos: [], word: []};
            if (!search.title) {
                let wordNum = -1;
                let off = 0;
                let wasSpace = true;
                for (let x of item.words) {
                    if (wasSpace) {
                        wordNum++;
                        lookup.word.push(off);
                    }
                    wasSpace = (x == ' ');
                    lookup.pos.push(wordNum);
                    off++;
                }
                lookup.word.push(off+1);

                let last = 0;
                start = [];
                for (let cur of item.start) {
                    last += cur;
                    start.push(last);
                }

                speakerPop = {};
                speaker = item.speaker.split('');
                counts = {};
                speaker.map(x => {
                    counts[x] = counts[x] ? counts[x] + 1 : 1;
                });
                counts["@"] = 0;
                counts = Object.entries(counts);
                counts.sort((a, b) => {
                    if (b < a) {
                        return -1;
                    }
                    if (a > b) {
                        return 1;
                    }
                    return 0;
                });
                counts.map(x => {
                    if (x[0] == "@") {
                        speakerPop[x[0]] = '';
                    } else {
                        speakerPop[x[0]] = ' ' + String.fromCharCode("A".charCodeAt(0) + Object.keys(speakerPop).length) + ": ";
                    }
                });
            }
        }

        if (!showHit(lookup.pos[hit], lookup.pos[hit+size])) {
            return false;
        }
        return true;
    });

    return ret;
}

async function showTranscript(data_num, start, len, itemID) {
    let batch = await getData(data_num, start, len);
    document.title = batch[itemID].title;
    let items = showHit(batch[itemID], '', true, null, null, {skip: 0, pos: 0, bail: 9999, found: 0});
    document.getElementById("results").replaceChildren(...items);
}

function notify(desc) {
    let searching = document.createElement('span');
    searching.innerText = desc;
    document.getElementById("results").replaceChildren(searching);
}

async function searchFor(search, skip=0, countOnly=false) {
    if (info === null) {
        info = await getData(0, 0, 100, "json");
        batches = await getData(...info.data);
    }

    if (!countOnly) {
        notify("Searching...");
    }

    let searchTerms = search.split(' ');
    let paginator = {
        skip: skip, 
        pos: 0, 
        bail: countOnly ? 100000 : 100, 
        found: 0,
        foundTitles: 0,
    };
    search = {
        terms: [],
        before: null,
        after: null,
        regex: false,
        logic: false,
        title: false,
        reverse: false,
        groups: [],
        orig: search,
    };

    for (let word of searchTerms) {
        let m = word.match(/^group:([^ ]+)( |$)/i);
        if (m != null) {
            search.groups.push(m[1]);
            continue;
        }
        m = word.match(/^after:([^ ]+)( |$)/i);
        if (m != null) {
            search.after = m[1];
            continue;
        }
        m = word.match(/^before:([^ ]+)( |$)/i);
        if (m != null) {
            search.before = m[1];
            continue;
        }
        m = word.match(/^(?:regex|re):([^ ]+)( |$)/i);
        if (m != null) {
            search.terms.push(m[1]);
            search.regex = true;
            continue;
        }
        m = word.match(/^title:([^ ]+)( |$)/i);
        if (m != null) {
            search.terms.push(m[1]);
            search.title = true;
            continue;
        }
        m = word.match(/^logic:([^ ]+)( |$)/i);
        if (m != null) {
            search.terms.push(m[1]);
            search.logic = true;
            continue;
        }

        if (word == "rev" || word == "reverse") {
            search.reverse = true;
        } else {
            search.terms.push(word);
        }
    }

    if (search.terms.join(' ') == 'list') {
        search.title = true;
        search.terms = [];
        paginator.bail = 100000;
    }

    if (search.terms.join(' ') == 'latest') {
        search.title = true;
        search.terms = [];
        paginator.skip = Math.max(0, totalItems - 25);
        paginator.bail = 10000;
    }

    if (search.logic) {
        let debugLogic = false;
        let nearAmount = 200;
        /* ########################################################################################################################################## */
        let terms = [];
        let state = {negate: false, new: true};
        let dumpState = termsToDump => {
            let termsPretty = [];
            for (let x of termsToDump) {
                if (x.oper == 'HIT') {
                    if (x.negate) {
                        termsPretty.push("!" + x.val);
                    } else {
                        termsPretty.push(x.val);
                    }
                } else {
                    termsPretty.push(x.oper);
                }
            };
            return termsPretty.join(" ");
        };
        if (debugLogic) {
            console.log(`  Stack: '${search.terms.join("', '")}'`);
        }
        let isWhole = false;
        for (let val of search.terms.join(' ').replace("(", " ( ").replace(")", " ) ").split(' ')) {
            if (val.length > 0) {
                if (val.search(/^(and|or|near)$/i) == 0) {
                    terms.push({oper: val.toUpperCase()});
                    state.new = true;
                } else if (val.search(/^(whole)$/i) == 0) {
                    isWhole = true;
                } else if (val == "(") {
                    terms.push({oper: "OPEN"});
                } else if (val == ")") {
                    terms.push({oper: "CLOSE"});
                } else if (val.search(/^(not)$/i) == 0) {
                    state.new = true;
                    state.negate = true;
                } else {
                    if (state.new) {
                        terms.push({whole: isWhole, oper: 'HIT', val: val, negate: state.negate});
                        state.new = false;
                        state.negate = false;
                    } else {
                        terms[terms.length-1].val += ' ' + val;
                    }
                }
            }
        };
        if (debugLogic) {
            console.log(`  Parsed: ${dumpState(terms)}`);
        }

        let hitOrVal = x => {
            /* Just see if an item is a hit or a val */
            return (x.oper == 'HIT') || (x.oper == 'VAL')
        };

        let isTrue = (x, words) => {
            /* See if an item is a True bool, or a hit that matches */
            if (x.oper == 'VAL') {
                return x.val;
            } else if (x.oper == 'HIT') {
                let ret;
                if (x.whole) {
                    ret = words.search(new RegExp("\\b" + x.val.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&') + "\\b")) >= 0;
                } else {
                    ret = (words.indexOf(x.val) >= 0);
                }
                if (x.negate) {
                    ret = !ret;
                }
                return ret;
            } else {
                throw new Error("Unable to parse syntax: " + JSON.stringify(x));
            }
        };

        let isWord = x => {
            /* See if an item is a positive hit */
            return x.oper == 'HIT' && !x.negate;
        };

        let range = (words, x, y, dest) => {
            /* Get extend of begin and end */

            if (x !== null) {
                if (x.oper == 'HIT' && x.begin == undefined && !x.negate) {
                    let temp = words.indexOf(x.val);
                    if (temp >= 0) {
                        x.begin = temp;
                        x.end = temp + x.val.length;
                    }
                }
            }

            if (y !== null) {
                if (y.oper == 'HIT' && y.begin == undefined && !y.negate) {
                    let temp = words.indexOf(y.val);
                    if (temp >= 0) {
                        y.begin = temp;
                        y.end = temp + y.val.length;
                    }
                }
            }

            if (x != null && y != null && x.begin != undefined && y.begin != undefined) {
                dest.begin = Math.min(x.begin, y.begin);
            } else if (x != null && x.begin != undefined) {
                dest.begin = x.begin;
            } else if (y != null && y.begin != undefined) {
                dest.begin = y.begin;
            }

            if (x != null && y != null && x.begin != undefined && y.begin != undefined) {
                dest.end = Math.max(x.end, y.end);
            } else if (x != null && x.begin != undefined) {
                dest.end = x.end;
            } else if (y != null && y.begin != undefined) {
                dest.end = y.end;
            }
        };

        let processTerms = (words, terms) => {
            let stack = [...terms];
            for (let cur of stack) {
                cur.begin = undefined;
                cur.end = undefined;
            }

            while (true) {
                /* Find and resolve parens */
                let foundPair = false;
                let depth = 0;
                let openAt = -1;
                let i = -1;
                for (let x of stack) {
                    i++;
                    if (x.oper == 'OPEN') {
                        if (depth == 0) {
                            openAt = i;
                        }
                        depth++;
                    } else if (x.oper == 'CLOSE') {
                        depth--;
                        if (depth == 0) {
                            /* Found an open and matching close, process the contents */
                            let temp = processTerms(words, stack.slice(openAt + 1, i));
                            stack = stack.slice(0, openAt).concat([{oper: 'VAL', val: temp[0], begin: temp[1], end: temp[2]}]).concat(stack.slice(i+1));
                            foundPair = true;
                            break;
                        }
                    }
                };
                if (!foundPair) {
                    break;
                }
            }
            while (stack.length > 1) {
                if (stack.length >= 3 && ((stack[0].oper == 'VAL' && !stack[0].val) || (stack[2].oper == 'VAL' && !stack[2].val)) && stack[1].oper == 'NEAR') {
                    /* x NEAR x, where one of the x is False */
                    stack = [{oper: 'VAL', val: false}].concat(stack.slice(3));
                } else if (stack.length >= 3 && stack[0].oper == 'HIT' && stack[1].oper == 'NEAR' && stack[2].oper == 'HIT') {
                    /* x NEAR x, where both of the x are hit */

                    let findMatch = (words, x, off) => {
                        if (stack[0].whole) {
                            let ret = words.slice(off).search(new RegExp("\\b" + x.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&') + "\\b"));
                            if (ret >= 0) {
                                return ret + off;
                            } else {
                                return ret;
                            }
                        } else {
                            return words.indexOf(x, off);
                        }
                    };

                    /* Find all the possible hits */
                    let locs = x => {
                        let ret = [];
                        let i = -1;
                        while ((i=findMatch(words,x,i+1)) >= 0) {
                            ret.push(i);
                        }
                        return ret;
                    };
                    let nears = 0;
                    let hits = [locs(stack[0].val)];
                    while (stack.length >= (2 * (nears + 1)) && stack[1 + nears * 2].oper == 'NEAR' && stack[2 + nears * 2].oper == 'HIT') {
                        hits.push(locs(stack[nears * 2 + 2].val));
                        nears++;
                    }
                    let allGood = true;
                    let pos = [];
                    for (let a of hits[0]) {
                        allGood = true;
                        pos = [a];
                        for (let other of hits.slice(1)) {
                            let found = false;
                            for (let b of other) {
                                if (Math.abs(a - b) <= nearAmount) {
                                    pos.push(b);
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                allGood = false;
                                break;
                            }
                        }
                        if (allGood) {
                            break;
                        }
                    }
                    if (allGood) {
                        stack = [stack[0]].concat(stack.slice(2 * nears + 1));
                        stack[0].begin = Math.min(...pos);
                        stack[0].end = Math.max(...pos);
                    } else {
                        stack = [{oper: 'VAL', val: false}].concat(stack.slice(2 * nears + 1));
                    }

                } else if (stack.length >= 3 && hitOrVal(stack[0]) && stack[1].oper == 'AND' && hitOrVal(stack[2])) {
                    /* x AND x */
                    if (isTrue(stack[0], words) && isTrue(stack[2], words) && isWord(stack[0]) && isWord(stack[2])) {
                        range(words, stack[0], stack[2], stack[0]);
                        stack = [stack[0]].concat(stack.slice(3));
                    } else {
                        let temp = {};
                        range(words, stack[0], stack[2], temp);
                        stack = [{oper: 'VAL', val: isTrue(stack[0], words) && isTrue(stack[2], words)}].concat(stack.slice(3));
                        range(words, temp, temp, stack[0]);
                    }
                } else if (stack.length >= 3 && hitOrVal(stack[0]) && stack[1].oper == 'OR' && hitOrVal(stack[2])) {
                    /* x OR x */
                    if ((isTrue(stack[0], words) || isTrue(stack[2], words)) && isWord(stack[0]) && isWord(stack[2])) {
                        if (isTrue(stack[0], words)) {
                            stack = [stack[0]].concat(stack.slice(3));
                        } else {
                            stack = [stack[2]].concat(stack.slice(3));
                        }
                    } else {
                        stack = [{oper: 'VAL', val: isTrue(stack[0], words) || isTrue(stack[2], words)}].concat(stack.slice(3));
                    }
                } else {
                    throw new Error("Invalid operator: " + dumpState(stack));
                }
            }

            if (stack.length == 1 && hitOrVal(stack[0])) {
                range(words, stack[0], stack[0], stack[0]);
                return [isTrue(stack[0], words), stack[0].begin, stack[0].end];
            } else {
                throw new Error('Invalid logic syntax: ' + dumpState(stack));
            }
        };

        search.logicFunc = words => {
            return processTerms(words, terms);
        };
        /* ########################################################################################################################################## */
    }

    let temp = [];
    let batchesTemp = batches;
    if (search.reverse) {
        batchesTemp = [...batchesTemp].reverse();
    }
    for (let batchInfo of batchesTemp) {
        if (paginator.bail == 0) {
            break;
        }
        let key = batchInfo.join('|');
        if (!(key in batchData)) {
            batchData[key] = await getData(...batchInfo);
        }
        let batch = batchData[key];
        let itemID = -1;
        let batchTemp = batch;
        if (search.reverse) {
            batchTemp = [...batchTemp].reverse();
        }
        for (let item of batchTemp) {
            itemID++;
            if (paginator.bail == 0) {
                break;
            }

            if (search.before != null) {
                if (item.published >= search.before) {
                    continue;
                }
            }
            if (search.after != null) {
                if (item.published <= search.after) {
                    continue;
                }
            }

            temp = temp.concat(showHit(item, search, false, batchInfo, itemID, paginator, countOnly));
        }
    }

    if (countOnly) {
        document.getElementById("totalsCount").innerText = 
            `Found ${paginator.bail == 0 ? 'at least ' : ''}${commafy(paginator.found)} hits in ${commafy(paginator.foundTitles)} episodes`;
    } else {
        if (!search.title) {
            if (paginator.found == 0) {
                let comment = document.createElement('span');
                temp.push(comment);
                comment.innerText = "(No matches found)";
            } else {
                let comment = document.createElement('span');
                temp.unshift(comment);
                comment.innerText = `Found ${paginator.bail == 0 ? 'at least ' : ''}${commafy(paginator.found)} hits in ${commafy(paginator.foundTitles)} episodes`;
                if (paginator.bail == 0) {
                    comment.id = "totalsCount";
                    let keep = document.createElement("span");
                    keep.className = "clickable";
                    keep.innerText = ", produce complete count.";
                    keep.onclick = () => {
                        searchFor(search.orig, 0, true).then();

                    };
                    comment.appendChild(keep);
                }
            }
        }

        document.getElementById("results").replaceChildren(...temp);
    }
}


function commafy(val) {
    return val.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

async function showCreation() {
    let info = await getData(0, 0, 100, "json");
    contextAfter = info.after;
    contextBefore = info.before;
    document.getElementById('created').innerHTML = `${info.created} with ${commafy(info.items)} entries`;
    totalItems = info.items;
}

function cacheData(workers, startAt) {
    if (info === null) {
        getData(0, 0, 100, "json").then(newInfo => {
            getData(...newInfo.data).then(newBatches => {
                info = newInfo;
                batches = newBatches;
                for (let i = 0; i < workers; i++) {
                    cacheData(workers, i);
                }
            });
        });
        return;
    }

    if (startAt < batches.length) {
        let key = batches[startAt].join('|');
        if (!(key in batchData)) {
            getData(...batches[startAt]).then(data => {
                batchData[key] = data;
                cacheData(workers, startAt + workers);
            });
        }
    }
}

document.addEventListener("DOMContentLoaded", function(event) {
    if (window.location.hash.substring(1, 5) == "rid=") {
        let temp = document.getElementById("info");
        if (temp != null) {
            temp.src = temp.src.replace(".png", "-rid.png");
        }
    }

    let info = window.location.hash.substring(1);
    info = info.split(",");
    if (info.length == 4 || info.length == 5) {
        document.getElementById("search_input").innerHTML = '';
        document.getElementById("footer").innerHTML = '';
        showTranscript(parseInt(info[0]), parseInt(info[1]), parseInt(info[2]), parseInt(info[3])).then(() => {
            if (info.length == 5) {
                let at = parseInt(info[4]);
                for (let cur of document.getElementsByTagName("span")) {
                    if (cur.at >= at) {
                        cur.scrollIntoView();
                        break;
                    }
                }
            }
        });
    } else {
        showCreation().then(() => {
            document.getElementById("search").focus();
            cacheData(4, 0);
        });
    }
});

function handleKey(e) {
    if (e.keyCode === 13) {
        e.preventDefault();
        let val = document.getElementById('search').value.trim();
        if (val.length > 0) {
            searchFor(val).then().catch(e => {
                notify("ERROR: " + e);
            });
        }
    }
}
</script>
</head>
<body>
<span id="search_input">
Search term: <input id="search" type="text" size=50 autocomplete="off" autocorrect="off" onkeyup="handleKey(event);"><br>
<span style="font-size: 80%;">
Usage:<br>
<div style="margin-left: 1em;">
"search term" = Search for "seach term"<br>
"list" = Show a list of all items<br>
"latest" = Show a list of most recent items<br>
"... after:xxx" = Show items that are published after xxx<br>
"... before:xxx" = Show items that are published before xxx<br>
"regex:xxx" = Search using regular expressions<br>
"logic:xxx" = Search using logic operators: AND, OR, NOT, NEAR, WHOLE, ()<br>
"title:xxx" = Search in the titles<br>
"reverse xxx" = Show search results in reverse order<br>
<!- - search_terms - ->
</div>
</span>
<br>
</span>
<span id="results">...</span>
<span class="created" id="footer"><hr>
Created: <span id="created">(loading)</span>
<!- - example_link - ->
</span>
</body>
</html>
-->
